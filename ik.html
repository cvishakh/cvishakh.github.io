<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>2-Bone IK Robot Arm with Constraints & Smooth Tracking</title>
  <style>
    body, html { margin:0; padding:0; overflow:hidden; background:#222; }
    canvas { display:block; }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <script>
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');

    let W = window.innerWidth, H = window.innerHeight;
    window.addEventListener('resize', () => {
      W = window.innerWidth; H = window.innerHeight;
      canvas.width = W; canvas.height = H;
    });
    canvas.width = W; canvas.height = H;

    const L1 = 150, L2 = 100;
    const shoulderMin = -Math.PI, shoulderMax = -Math.PI/2;
    let mx = W/2, my = H/2;
    window.addEventListener('pointermove', e => { mx = e.clientX; my = e.clientY; });

    let curShoulder = 0, curElbow = 0;
    const damp = 0.1;

    // Compute smallest difference between angles
    function angleDiff(target, current) {
      let diff = target - current;
      diff = ((diff + Math.PI) % (2*Math.PI)) - Math.PI;
      return diff;
    }

    function draw() {
      ctx.clearRect(0,0,W,H);
      const bx = W/2, by = H/2;
      // base
      ctx.fillStyle = '#555';
      ctx.fillRect(bx-60, by-20, 120, 20);

      // target vector
      let dx = mx - bx, dy = my - by;
      let d = Math.hypot(dx, dy);
      const maxR = L1 + L2, minR = Math.abs(L1 - L2);
      if (d > maxR) d = maxR;
      if (d < minR) d = minR;
      const at = Math.atan2(dy, dx);

      // shoulder IK
      let cosPhi = (d*d + L1*L1 - L2*L2) / (2*d*L1);
      cosPhi = Math.max(-1, Math.min(1, cosPhi));
      const phi = Math.acos(cosPhi);
      const unclampedSh = at + phi;
      const targetShoulder = Math.max(shoulderMin, Math.min(shoulderMax, unclampedSh));
      const shoulderClamped = (targetShoulder !== unclampedSh);

      // elbow IK
      let targetElbow;
      if (shoulderClamped) {
        // elbow points towards mouse from joint
        const jx = bx + L1 * Math.cos(targetShoulder);
        const jy = by + L1 * Math.sin(targetShoulder);
        let dx2 = mx - jx, dy2 = my - jy;
        const dist2 = Math.hypot(dx2, dy2);
        if (dist2 > L2) {
          dx2 *= L2 / dist2;
          dy2 *= L2 / dist2;
        }
        targetElbow = Math.atan2(dy2, dx2);
      } else {
        let cosT = (L1*L1 + L2*L2 - d*d) / (2*L1*L2);
        cosT = Math.max(-1, Math.min(1, cosT));
        const theta = Math.acos(cosT);
        targetElbow = targetShoulder - (Math.PI - theta);
      }

      // smooth interpolation
      curShoulder += angleDiff(targetShoulder, curShoulder) * damp;
      curElbow   += angleDiff(targetElbow, curElbow) * damp;

      // joint positions
      const jx = bx + L1 * Math.cos(curShoulder);
      const jy = by + L1 * Math.sin(curShoulder);
      const ex = jx + L2 * Math.cos(curElbow);
      const ey = jy + L2 * Math.sin(curElbow);

      // draw segments
      ctx.lineCap = 'round'; ctx.lineWidth = 14;
      ctx.strokeStyle = '#08f'; ctx.beginPath(); ctx.moveTo(bx,by); ctx.lineTo(jx,jy); ctx.stroke();
      ctx.strokeStyle = '#0f8'; ctx.beginPath(); ctx.moveTo(jx,jy); ctx.lineTo(ex,ey); ctx.stroke();

      // joints
      ctx.fillStyle = '#ff0';
      ctx.beginPath(); ctx.arc(bx,by,12,0,2*Math.PI); ctx.fill();
      ctx.beginPath(); ctx.arc(jx,jy,12,0,2*Math.PI); ctx.fill();

      // curved claw
      const clawLen = 30, off = 0.6, bend = 1.2;
      ctx.strokeStyle = '#f44'; ctx.lineWidth = 6;
      // jaw1
      const a1 = curElbow + off;
      const cx1 = ex + (clawLen*0.6)*Math.cos(curElbow + bend);
      const cy1 = ey + (clawLen*0.6)*Math.sin(curElbow + bend);
      ctx.beginPath(); ctx.moveTo(ex,ey);
      ctx.quadraticCurveTo(cx1, cy1, ex + clawLen*Math.cos(a1), ey + clawLen*Math.sin(a1));
      ctx.stroke();
      // jaw2
      const a2 = curElbow - off;
      const cx2 = ex + (clawLen*0.6)*Math.cos(curElbow - bend);
      const cy2 = ey + (clawLen*0.6)*Math.sin(curElbow - bend);
      ctx.beginPath(); ctx.moveTo(ex,ey);
      ctx.quadraticCurveTo(cx2, cy2, ex + clawLen*Math.cos(a2), ey + clawLen*Math.sin(a2));
      ctx.stroke();

      requestAnimationFrame(draw);
    }
    draw();
  </script>
</body>
</html>
